[{"title":"clean code笔记","date":"2022-11-15T14:25:33.000Z","url":"/2022/11/15/clean-code%E7%AC%94%E8%AE%B0/","tags":["clean code"],"content":"简介观看笔记：Clean Code（整洁代码）Bob大叔现场演讲合集 - Bob大叔激情四射的演讲 让你重拾对编程的热情，对代码的执着。 理念 写代码是给需要理解的人看的。 clean code走的慢，但是走的好，走的好才能走的远。 代码规范 代码扁平化。 一个函数最好在一个屏幕内写完。 同一个函数内容抽象层次相同。 金字塔语义设计，标题、摘要、详情。 一个函数只做一件事。即不能从中再抽象出更多的事情。 函数参数不超过3个。 函数传参不要传入bool。 纵向阅读时不需要往回看。 不要使用switch。因为当添加一个新的开关时，所有相关switch都需要改。用多态替代实现，将处理函数写在新增的类中。switch创建的依赖较多，重新编译时要更新更多的模块。 有副作用的函数：调用会改变系统状态，如new，delete，open、close。通常成对出现。利用lamada传入函数的方式，将副作用成对的函数放在一起调用。所以有返回值的函数不应该存在副作用。 try在函数中占全文，不应在try的外面写另外的语句。（一个函数只做一件事） 避免重复。需要遍历处理时，抽象出一个遍历函数，利用lamada传入处理函数。 每行最好最多在50～100个字符。 变量名称长度与作用域大小成正比。函数名长度与作用域大小成反比。 info、data名称歧义混淆。 注释注释是用来表达代码本身未能表达的意思。每个注释都意味着一次失败。 尽量用函数名替代注释，除非函数名应用到了某些设计模式。 正则表达式例子。 单元测试命名的开关。 一些这样写作的原因。 不要谈论不在注释处的代码。 测试 发布代码时，确保代码整洁、高效、可运行、测试过的，了解其工作流程。 software，软+件，灵活易改变的产品，敏捷首先要求充分低耦合的设计。 代码应该随着时间的推移越来越好而不是屎山。 为自己写的代码写单元测试，测试自己写的每一行代码。 测试是系统设计的一部分，将测试与系统解耦。 测试人员应该一无所获。 尽可能自动化测试，手动测试总是会忽略某些测试。 互相理解同事的代码，定期交流（面对面比只code review高效），当有些人临时不在时，可以互相“掩护”。 估时很难定。给出三个时间点，最好情况（纯工作时常）、一般情况（各种事情穿插）、最差情况。 "},{"title":"浏览器缓存","date":"2022-10-27T06:30:05.000Z","url":"/2022/10/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","content":"参考链接"},{"title":"手写MVVM框架-step7-diff算法","date":"2022-10-15T03:23:44.000Z","url":"/2022/10/15/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step7-diff%E7%AE%97%E6%B3%95/","tags":["JavaScript","MVVM","vue","react","diff"],"content":"问题定义之前的步骤只实现了对dom“增删改查”中的“改”和“查”，“增”和“删”还未实现。diff算法其实就是用来实现“增删改”dom树的一个解决方案。具体来讲，在更新dom树时会有当前显示的旧的虚拟dom树、和更新目标新的虚拟dom树，如果直接进行dom树的替换，虽然实现起来较为简单，但是性能非常差劲，所以diff算法的目标就是，找到从旧dom树转化为新dom树所需要的最小编辑操作，并且将这一系列操作应用到真实dom树中以实现dom树的更新。故可将问题分为如下两个步骤： 找出更新的编辑操作。对比新旧两颗虚拟dom树，找到从旧dom树到新dom树的操作序列。 打补丁。执行操作序列更新真实dom树。 找出更新的编辑操作问题可以细化为，输入两颗虚拟dom树的根节点pre和cur，实现一个函数diff，可以返回从pre变化成cur的更新操作。目前暂时实现一个初始版本，仅用如下四种操作进行更新： update。更新节点，节点类型不变，只是props属性有变化。 delete。删除节点，旧dom树有，新dom树无。 insert。插入节点，旧dom树无，新dom树有。 replace。替换节点，新旧节点类型不同，直接替换。 大体思路为深度优先遍历新旧虚拟dom树的并集节点（即对于同一层级，遍历个数为新旧树中节点树最大值，如果新dom树节点数较多，那么多出来的节点执行insert操作，反之执行delete操作），并且将遍历顺序当作节点的唯一索引。 注意涉及到delete、insert和raplace的节点，并不需要继续往下深度优先遍历，因为对于delete来说，反正要删除改节点，即也删除了该节点下的所有节点；对于insert来说，新增的子节点信息均在新节点中；replace同理。（因此也会有很大的性能问题，没有考虑兄弟节点顺序变化可复用的情况） 其中对于update操作的属性对比diffAttribute函数的实现如下，首先遍历旧节点找出新节点更新的内容，如果新节点没有则会被设置为undefined意为删除。然后再遍历新节点找出旧节点中没有的属性： 执行操作执行diff后的编辑操作的遍历顺序同diff时相同，也是遇到非update的操作不再继续，以保证遍历顺序和节点索引的一致性。 在这里的实现为更新后，新的虚拟dom树为对应在真实dom上的节点，所以对于没有变化的节点要拷贝旧节点的真实dom引用。 在执行操作的时候对于update操作为了复用真实dom节点，也要拷贝真实dom节点的引用。 测试为了测试方便，封装一个changeTo函数用来更新虚拟dom树为另一个HTML文本描述的形式： 测试： 可以看到1秒后换为template2的dom树，2秒后又换会template： 参考链接"},{"title":"手写MVVM框架-step6-实现v-model双向绑定","date":"2022-10-13T03:21:08.000Z","url":"/2022/10/13/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step6-%E5%AE%9E%E7%8E%B0v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","tags":["JavaScript","MVVM","vue","react","双向绑定","v-model"],"content":"问题定义上一步通过Proxy监听数据的变化，从而对dom节点进行更新，相当于是单向数据驱动的更新。现在想通过v-model标签，实现vue双向绑定的更新机制。 具体来说，通过添加input标签的v-model属性标识绑定的值，监听input的变化实时改变该值，从而通过Proxy实现的单向更新对用到该变量的所有dom节点都进行更新。测试样例如下： 具体步骤可细化成三个部分： 识别input标签。 识别v-model属性。 监听input变化，更新v-model绑定的变量。 识别input和v-modelinput的识别即在token关键词中添加相应标签即可： 对于v-model的识别，由于-不能用作js变量名，所以之前在step2中基于添加this识别属性名的方法有些不妥，需要把-转换成_，所以这里换用正则匹配的方式对属性内容进行解析。具体来讲首先在update中对input和v-model进行特殊处理，将v-model后绑定的变量转化成具体的值写入value变量中： 监听input变化通过在render创建具体虚拟dom时对oninput事件进行重载，监听到变化调用组件的setState触发更新： 测试"},{"title":"手写MVVM框架-step5-组件更新优化","date":"2022-10-12T07:32:12.000Z","url":"/2022/10/12/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step5-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E4%BC%98%E5%8C%96/","tags":["JavaScript","MVVM","vue","react","组件","观察者模式","proxy"],"content":"问题定义针对上一步实现的update，每次更新都需要从根节点遍历更新所有节点的问题，效率很差，如果可以只更新部分变化的节点，则可以大大的优化渲染。具体来讲，实现一个函数proxy监听组件props的改变，当props的某些属性改变时，只重新update引用该属性变量的虚拟节点。 使用Proxy监听props的读取和改变众所周知，vue2通过defineProperty实现双向绑定，vue3则是通过Proxy实现的双向绑定。在这里，我们可以巧妙的运用Proxy对get和set的监听，以实现虚拟节点和props属性的映射。 具体来讲，通过get监听哪些虚拟节点调用该props属性值key，通过curNode变量来记录当前update的节点，通过set来判断如果key值变化则只更新在get节点使用过该key的虚拟节点： 其中对于key和虚拟节点的记录，其实可以抽象成观察者模式进行实现，即一个on函数记录key和节点的映射关系，一个getElements函数得到key对应的所有节点： 最终proxy实现如下，其中在监听到修改以后需要采用异步更新，否则还无法得到更新后的props结果： 其中在resolveJsx中需要通过has判断需要调用的props属性，从而按需触发Proxy的set函数（这里仅使用了字符串匹配，没有考虑关键字不是变量的情况）： 修改调用结构在之前写的createComponent、update、render函数功能有一些耦合，例如createComponent解析HTML文本的同时也解析了jsx内容，update是重新解析jsx文本同时更新虚拟dom和真实dom，render是根据虚拟dom创建真实dom到指定的dom节点上。 为了使proxy监听的部分在所有阶段都生效（之前如果未update则proxy无效，现在强制在render前update），现将其功能解耦如下： createComponent函数仅负责解析HTML文本，并创建仅保存了jsx文本的虚拟节点。 update函数仅负责根据组件的props重新计算每一个虚拟dom节点的props，并且如果有绑定真实dom节点则更新。 render函数仅负责根据虚拟dom节点创建真实dom节点。 这样初始换的流程就变成如下形式： 优化一次setState多次更新节点问题但是目前如果待更新的节点有子父级的关系，那么处于较低层级的虚拟节点可能会因为父节点的更新而重复更新，而且修改多个props属性值，proxy的set函数也会被调用多次，比如如下例子： 通过调试可知，name所在的textNode节点被渲染了2次。 故优化方法可以每一次setState创建一个唯一标记，每次更新完在其虚拟dom上记录该标记，下次调用时如果标记相同则不执行更新： 测试测试结果如下： 而且采用如上setTimeout形式对结果进行更新，对于多个连续的setState也有优化，在回调更新时均以最后一个setState的updateToken为基准更新一次即可： 问题 jsx解析虚拟节点对key的引用问题。目前在判断虚拟dom是否使用了某个key，仅通过字符串匹配的方式进行校验，如果关键字在jsx中不作为变量名，则也会被记录的问题（比如字符串&#39;name&#39;）。所以需要根据js语法判断当前字符是否作为变量名被使用，最优的解决方案还是通过babel对其进行语法分析，从而得出使用的变量名有哪些，所以这可能都是vue和react都是用babel进行jsx语法转换的原因吧，文字匹配确实很麻烦。 "},{"title":"手写MVVM框架-step4-组件的抽象与更新","date":"2022-10-11T10:03:52.000Z","url":"/2022/10/11/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step4-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%9B%B4%E6%96%B0/","tags":["JavaScript","MVVM","vue","react","setState","组件更新","组件"],"content":"问题描述之前实现的方法可以通过trans函数将jsx文本解析成虚拟dom，并通过render函数将虚拟dom转换成真实dom显示到网页上。 下一步的要做的是如果jsx中的变量有更新，也可以将真实的dom节点进行更新。具体来讲，实现一个函数update，可以根据现有的jsx变量重新更新真实dom的对应值，而无需重新生成一边所有的真实dom： 组件抽象之前的虚拟dom节点定义如下： 在虚拟dom的构建过程中，我们写了一个CreateElementHandle函数帮助构建。其中为所有虚拟dom创建了一个根虚拟节点root，其类型为div，props为空，children为真正构建出的虚拟dom的根节点，之所以如此构建（而不是最顶层是虚拟dom的数组），最主要考虑的就是有一些属性是该jsx文本对应的所用虚拟dom节点共用的，比如与jsx相关的jsxProps对象，不应添加到所有的虚拟dom节点上，而是应该抽象到最顶层进行共用，所以创建一个根虚拟dom节点进行承载。 不过其实所谓的根虚拟dom节点，也就是抽象意义上的组件。一个组件由许多的虚拟dom节点组成，该组件上的一些属性可以被其所有的子虚拟dom节点共用，同时组件对象本身也是一个虚拟dom节点。因此可以抽象出一个组件类来承载这一逻辑关系： CreateElementHandle函数的功能也就变成了帮助创建组件，可以将其修改为CreateComponentHandle： 所以trans的功能实际上就是根据jsx文本和对应的props属性，创建一个组件，故可将其更名为： 组件更新所以接下要实现的目标就是，对于一个组件对象root，如果其componentProps进行了更新，那么就对应更新虚拟dom的值，并将其更新到真实dom上。即在Component中实现一个update函数： 所以关键步骤就是，需要保留每个虚拟dom所对应的jsx文本，从而实现根据componentProps的变换重新生成对应的props。因此在jsx文本解析的时候需要对原始jsx进行保留处理，可在createComponent函数修改如下： 同时在对真实dom更新的setProps函数中，对jsxStr进行过滤： 然后即可将update函数实现如下： 测试 可以看到2000ms后html的内容进行了变化： 同时还可以据此，在组件中封装一个setState函数进行异步更新： 则可以如下调用： 一些问题 目前只能从组件的根节点深度遍历更新，而且对于不需要更新的节点重新解析了jsx。 对于连续的更新仍旧会依次运行完，即使最后一次更新才是最终需要渲染的结果。 "},{"title":"手写MVVM框架-step3-jsx子集解析","date":"2022-10-09T14:01:03.000Z","url":"/2022/10/09/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step3-jsx%E5%AD%90%E9%9B%86%E8%A7%A3%E6%9E%90/","tags":["JavaScript","MVVM","vue","react","jsx","沙箱"],"content":"问题定义接下来的任务是解析HTML文本中的jsx代码，生成js运行后的文本，然后再进入正常的渲染流程。即实现一个函数resolveJsx，输入原始文本str和所需变量jsxProps，实现将样例文本如下进行转换： 解决方案首先通过正则匹配，将两个大括号中的内容取出来： 得到其中的内容之后，将其当作js文本执行得到结果。直觉上讲可以使用eval运行js得到结果，但是如何将其中用到的变量对应到jsxProps中是一个问题。 在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。 简单来讲，沙箱这个概念应用于JavaScript时，就是创建一个新的运行环境来运行指定js代码，我们可以通过创建一个沙箱来执行其中的js文本，并且可以提前设置环境中的预制变量，从而应用jsxProps中的变量。沙箱的具体内容可参照如下：浅析 JavaScript 沙箱机制沙箱实现 JavaScript 沙箱的几种方式 with实现沙箱解析jsx在非严格模式下，可以通过with改变指定代码块下的作用域，即with语句是将某个对象添加到作用域链的顶部，最简单的示例比如： 所以可以将resolveJsx简单实现如下： 这样会有作用域链仍旧向上查找的问题，解决方案可参照上面的参考链接，通过Proxy对访问进行过滤。 iframe实现沙箱但是with仅限在非严格模式下使用，因为考虑到es6 module的使用，会默认启用严格模式，所以这里采用iframe创建一个运行环境来执行。大体思路类似，首先利用iframe创建一个contentWindow，然后将jsxProps中的属性都定义在contentWindow环境中，然后在该环境运行js代码得到结果： 然后只需要在之前的trans函数添加jsxProps参数输入，并且在解析value和HTML标签属性的地方对文本进行替换即可： 测试 结果 一些问题 目前还只是匹配了jsx的子集，对于js和HTML结合的语句和jsx嵌套未进行处理，主要瓶颈在于jsx文本的解析，比如： 对未找到props属性没有做特殊的异常处理，目前只是会报错在iframe中运行的错误，但是没有给出具体是因为框架哪里写的不对，报错异常显示不友好。 iframe多次创建和删除问题。随着resolveJsx函数的多次调用，其中的iframe也频繁的创建和删除，会有一定的性能问题。可以通过单例模式创建iframe，每次运行时刷新环境变量，或者将iframe声明在trans函数作用域的头部以防止频繁创建和删除。 "},{"title":"手写MVVM框架-step2-props解析和render","date":"2022-10-08T12:17:48.000Z","url":"/2022/10/08/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step2-props%E8%A7%A3%E6%9E%90%E5%92%8Crender/","tags":["JavaScript","虚拟dom","MVVM","vue","react","render","词法分析","正则表达式"],"content":"问题定义在转化成虚拟dom节点之后，下一步就是将虚拟dom节点转化为真实的dom节点展示在浏览器中，但是在这之前，还需要将HTML标签中的属性添加到虚拟dom节点的props中，故问题定义如下： 解析HTML标签的属性，到虚拟dom节点的props中。 实现一个函数render，将虚拟dom节点转换并挂载到真实dom节点上。 解析props问题细化之前已经可以通过对’&lt;’和’&gt;’符号进行标记，拿到HTML标签的内容，但是还未对其内容进行解析，即接下来的任务是从标签内容字符串中解析出标签类型type，和标签属性对象props。即实现一个函数getTypeProps： 目前的框架都是先通过 babel 编译成抽象语法树（AST），然后在编译成对应虚拟 dom 构造函数的调用形式，（ React 是通过babel将 jsx 转换为h函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式，但是vue-loader内部本质还是调用的babel进行编译转换）所以不会涉及对字符串的解析。不过本着重头造轮子的原则，这里给出两种简易的的HTML文本解析方法，肯定有考虑不周的地方，敬请指正。 利用正则进行解析首先，先区分出出标签类型文本和标签属性文本： 解析出来的propsStr字符串为： 构建对应正则表达式，[ ]+[a-zA-Z][a-zA-Z0-9-]*表示至少一个空格之后的、由字母开头的、由字母数字或’-‘构成的词；= *&#39;[^&#39;]+&#39;表示等于号后任意空格后有有字符&#39;,并且最有有字符&#39;结尾，中间包含至少一个除了&#39;以外的其他字符。（中间没有字符则匹配不上，如id=&#39;&#39;则不参与匹配）最后的g表示全局匹配多组，利用match函数找出所有匹配的子串。 对于字符&quot;也是同样的匹配方法。 故可将解析props对象的函数写成如下形式： 利用eval和this构造props第一步同使用正则表达式，仍旧将type和propsStr分开，得到propsStr，思路是利用eval直接运行propsStr里面的内容，让其创建出对应名称的属性到props对象上，即实现一个函数appendThis，将propsStr中每个属性内容的开头添加this.，结尾添加分号;，再通过new function的构造参数形式构造出一个props对象： 对于字符串key=&quot;value&quot;大体思路是根据等于号(&#x3D;)定位位置，然后在key的前面加上this.，在&quot;value&quot;的后面加上;，同时考虑等号周位空格的情况key = &quot;value&quot;;： 其中由于要同时匹配’和”字符，但是indexOf不支持正则表达式，search不支持从中间查找，所以自行封装了支持正则表达式的可从中间查找的函数searchIndexOf。（indexOf与match区别） 创建props实现如下，这里为了防止用new构建出来的props留有构造函数的引用而导致内存泄漏，使用Object.assign进行了浅拷贝： 构建type和props综上，解析type和props实现如下，暂时采用eval+this的方法对props进行创建： 然后只需要在之前的trans函数中，调用getTypeProps得到type和props，再进行虚拟dom的创建： render渲染虚拟dom为真实dom渲染虚拟dom成真实dom主要就是利用document.createTextNode创建文本节点，document.createElement和appendChild创建和添加真实节点，通过递归调用的形式对虚拟dom树进行遍历，其中render接收两个参数，第一个是当前虚拟dom节点，第二个是该虚拟dom节点对应的父真实dom节点。 参考链接"},{"title":"手写MVVM框架-step1-HTML与虚拟dom转换","date":"2022-10-06T07:42:17.000Z","url":"/2022/10/06/%E6%89%8B%E5%86%99MVVM%E6%A1%86%E6%9E%B6-step1-HTML%E4%B8%8E%E8%99%9A%E6%8B%9Fdom%E8%BD%AC%E6%8D%A2/","tags":["JavaScript","虚拟dom","MVVM","vue","react"],"content":"虚拟dom节点 参数 type: 指定元素的标签类型，如’li’, ‘div’等 props: 表示指定元素身上的属性，如class, style, 自定义属性等 children: 子节点，数组形式 parent: 父节点，指向父虚拟节点的地址，方便处理 问题定义 给定一串html文本，实现一个trans函数将html文本转换成对应的虚拟dom对象。 给定一组虚拟dom对象，实现一个函数toHTML，将其转化成对应的HTML文本。 HTML文本转虚拟dom具体可将转化过程分为两部分，第一部分是对HTML文本进行词法分析，类似于括号匹配，根据HTML文本规则进行解析；第二部分是构建虚拟dom树，根据HTML的层次关系构建虚拟dom对象。 HTML文本词法分析大致流程是： 对HTML文本进行空格的预处理。 匹配每一组尖括号包裹的文本，分别有三种情况（&lt;div&gt;, &lt;div&#x2F;&gt;, &lt;&#x2F;div&gt;）。 在词法分析过程中通过栈stack判断标签配对的一致性。 在解析过程中将解析到的内容交给vEleHandle处理构建虚拟dom对象。 根据层级构建虚拟dom树整体思路是： 维护上一次添加进来的节点和上一个节点的层级。 判断新添加进来节点的层级： 如果新层级 等于 上一个节点层级，作为上一个节点的兄弟节点加入； 如果新层级 小于 上一个节点层级，作为对应层级的兄弟节点加入； 如果新层级 大于 上一个节点层级，作为上一节点的子节点加入。 根据虚拟dom构建HTML文本深度遍历+层级记录 测试 问题未考虑标签节点和直接文字并列的情况，如： 改进原因出在虚拟dom添加值的地方（trans函数第19行）： 这里addValue只对最后加进去的节点进行值得添加，在标签外面的文本自然就被添加进上方最近的节点当中，解决方法是对每一个单独的文字用一个新的虚拟dom节点包裹，如使用&lt;text&gt;标签： 这时生成的文本是带有&lt;text&gt;标签的： 然后只需在生成的文本最后（19行、20行）正则匹配删除掉&lt;text&gt;标签： 成功复原HTML文本！"},{"title":"Promise并发限制","date":"2022-09-28T06:34:03.000Z","url":"/2022/09/28/Promise%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6/","tags":["js","JavaScript","promise","并发限制"],"content":"题目描述实现一个Promise.limitConcurrency函数，可以将输入数组中的Promise任务全部并发执行并返回结果(不考虑输入任务为非Promise)，但是同一时间的并发数量最大为limits。 返回一个数组，包含每个任务的成功或者失败的结果，返回结果的测试样例如下： 思路一先运行limits个任务，然后在每次运行结束的回调中继续运行下一个。 思路二模拟多线程，每次运行完唤醒其他未运行的任务，未运行的任务被调用时检查可用资源，如果有资源则运行。 思路三维护一个正在运行的任务池，利用promise.race监听任务池中的在某个任务运行完成，并添加新的未运行的任务。每个任务完成后把自己从池子中删除，保证池子中均为正在运行的任务。 "},{"title":"函数柯里化","date":"2022-09-04T14:29:58.000Z","url":"/2022/09/04/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","tags":["js","javascript","柯里化"],"content":"简介比如一个简单的add相加函数，利用高阶函数的特性将其封装成链式调用形式： 最简单的封装即直接利用闭包生写： 柯里化柯里化工厂，输入一个函数，返回这个函数的柯里化形式。 利用闭包暂存参数 利用bind的偏函数性质暂存参数 使用两种方式各有优缺点吧，第一种可以在生成柯里函数的时候绑定参数，第二种则比较简介和优雅，省去了用于闭包存参数的数组。 直接写柯里函数不利用工厂的方式，直接书写柯里函数，主要思路仍旧是创建一个函数，返回该函数： 谜之柯里化最近面试还遇到了一个柯里化问题，即实现自由参数长度的add函数，使得如下成立： 因为不能确定柯里化的长度，即只能在调用的时候确定返回数字，运算的时候仍然返回函数，在面试官的提醒下，调用的时候会触发toString方法，可以通过重载toString方法实现，但是当时没做出来，后续思考后实现如下。 依据直接书写柯里化的方法，重载返回的fn的toString方法，将计算结果的方法写在fn.__proto__的toString中，并且要定义在fn里面，以利用闭包获取参数。 优化版本可进一步优化防止污染Function.prototype的toString： 思考睡了一觉白天又想到，其实也可以不用创建fn，直接返回一个bind，然后在外面绑定toString方法： 但主要问题是，这样在调用toString的方法时，不能通过this获取add的偏函数参数，之前用fn写到里面的原因是利用闭包暂存函数的参数，所以将计就计的话可以把参数暂存到add函数的一个属性args上： 两行return完美实现！ 但是说这样实现的话，会污染add的一个属性名args用来传递参数，并且在函数外部也可以访问内部的参数，还会涉及到修改了args的问题，算是一种从外部访问函数内部参数的次优解吧。 后记后来在面试中又遇到了类似的题目，在面试官的提示下写了出来，发现之前想复杂了，只需要把输入的参数暂存就好。 "},{"title":"死锁","date":"2022-08-28T06:33:33.000Z","url":"/2022/08/28/%E6%AD%BB%E9%94%81/","tags":["操作系统","死锁"],"content":"如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。 死锁条件死锁发生时，以下四个条件一定同时满足，如果其中任何一个条件不成立，死锁就不会发生： 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。 处理死锁策略鸵鸟算法忽略，假装没有死锁问题。考虑解决死锁的代价、死锁发生的频度、系统因各种原因崩溃而重启的次数、死锁的后果等综合因素，不管也许没什么问题。如果死锁平均每5年发生一次，而每个月系统都会因硬件故障、编译器错误或者操作系统故障而崩溃一次，那么大多数的工程师不会以性能损失和可用性的代价去防止死锁。 死锁检测多类型单资源死锁检测最简单的情况即每种类型只有一个资源。这样的系统可能有一台扫描仪、一台CD刻录机、一台绘图仪和一台磁带机，但每种类型的资源都不超过一个，即暂时排除了同时有两台打印机的情况。那么其实就可以抽象成一张资源分配图（单向图），假设一个系统包括A到G共7个进程，R到W共6种资源。资源的占有情况和进程对资源的请求情况如下： A进程持有R资源，且需要S资源。 B进程不持有任何资源，但需要T资源。 C进程不持有任何资源，但需要S资源。 D进程持有U资源，且需要S资源和T资源。 E进程持有T资源，且需要V资源。 F进程持有W资源，且需要S资源。 G进程持有V资源，且需要U资源。 显然，可将单资源的死锁检测当作单向图的环路检测，即对每一个节点当作一个树的根节点进行深度优先搜索。 多类型多资源死锁检测当有多种相同的资源存在，就需要采用一种矩阵的方式来检测死锁，如下图所示： 主体由两个矩阵构成，一个是当前分配矩阵C(n x m)，一个是请求矩阵R(n x m)，其中n表示进程数，m表示资源类型数，Cij即表示第i个进程已占有Cij个j资源，Rij表示第i个进程一共需要Rij个j资源。E(1 x m)表示每个资源的总数，A(1 x m)表示当前状态下每种资源剩余的数量。 因此死锁检测的基本思路是，根据当前资源剩余数量找到一个进程，使得可以满足该进程所有所需资源，并假设该进程运行完毕将之前占有的资源返还给资源池中。然后继续利用剩余资源池寻找下一个满足条件的进程，直到找不到满足条件的进程。剩余未被找到的进程则处于死锁当中。 比如下图的情况不存在死锁。由于当前剩余的A&#x3D;(2 1 0 0)，不能够满足进程1的(2 0 0 1)和进程2的(1 0 1 0)，但是可以满足进程3(2 1 0 0)，于是假设进程3运行完毕，将资源返还的资源池中，则A&#x3D;(2 2 2 0)。接着剩余资源则可满足进程2，然后满足进程1，于是不存在死锁。 如果将图中的R2改成(2 1 0 1)，则不能满足所有进程，会出现死锁。 死锁恢复抢占恢复在不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回。比如将激光打印机从它的持有进程那里拿走用作其他事项，然后将该进程挂起，待归还时在将该进程恢复。这种做法是否可行主要取决于该资源本身的特性。用这种方法恢复通常比较困难或者说不太可能。若选择挂起某个进程，则在很大程度上取决于哪一个进程拥有比较容易收回的资源。 回滚恢复周期性的进行状态快照和检查点保存。进程检查点检查就是将进程的状态写入一个文件以备以后重启。该检查点中不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。为了使这一过程更有效，新的检查点不应覆盖原有的文件，而应写到新文件中。这样，当进程执行时，将会有一系列的检查点文件被累积起来。 一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在该检查点后所做的所有工作都丢失。 杀死进程最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。杀死进程的选取也很讲究，如何找到代价最小的被进程的集合也是一个难题，包括最小杀死进程的数量以及杀死各个进程的代价等。 另一方面，最好杀死可以从头开始重新运行而且不会带来副作用的进程。比如，编译进程可以被重复运行，由于它只需要读入一个源文件和产生一个目标文件。如果将它中途杀死，它的第一次运行不会影响到第二次运行。而更新数据库的进程在第二次运行时并非总是安全的。如果一个进程将数据库的某个记录加1，那么运行它一次，将它杀死后，再次执行，就会对该记录加2，显然是错误的。 死锁避免安全状态和不安全状态接着多类型多资源的死锁检测，如果检测不到死锁则称当前的状态为安全状态，如果检测到死锁则称该状态为不安全状态。 银行家算法则是对于每个资源请求进行判断，如果当前的请求将会从安全状态转移到不安全状态，则不予以分配资源，如果仍旧是安全状态则允许分配。 资源轨迹图避免死锁的主要算法是基于一个安全状态的概念。 如图所示中，我们看到一个处理两个进程和两种资源（打印机和绘图仪）的模型。横轴表示进程A执行的指令，纵轴表示进程B执行的指令。进程A在I1 处请求一台打印机，在I3 处释放，在I2 处请求一台绘图仪，在I4 处释放。进程B在I5 到I7 之间需要绘图仪，在I6 到I8 之间需要打印机。 图6-8中的每一点都表示出两个进程的连接状态。初始点为p，没有进程执行任何指令。如果调度程序选中A先运行，那么在A执行一段指令后到达q，此时B没有执行任何指令。在q点，如果轨迹沿垂直方向移动，表示调度程序选中B运行。在单处理机情况下，所有路径都只能是水平或垂直方向的，不会出现斜向的。因此，运动方向一定是向上或向右，不会向左或向下，因为进程的执行不可能后退。 当进程A由r向s移动穿过I1 线时，它请求并获得打印机。当进程B到达t时，它请求绘图仪。 图中的阴影部分是我们感兴趣的，画着从左下到右上斜线的部分表示在该区域中两个进程都拥有打印机，而互斥使用的规则决定了不可能进入该区域。另一种斜线的区域表示两个进程都拥有绘图仪，且同样不可进入。 如果系统一旦进入由I1 、I2 和I5 、I6 组成的矩形区域，那么最后一定会到达I2 和I6 的交叉点，这时就产生死锁。在该点处，A请求绘图仪，B请求打印机，而且这两种资源均已被分配。这整个矩形区域都是不安全的，因此决不能进入这个区域。在点t处惟一的办法是运行进程A直到I4 ，过了I4 后，可以按任何路线前进，直到终点u。 需要注意的是，在点t进程B请求资源。系统必须决定是否分配。如果系统把资源分配给B，系统进入不安全区域，最终形成死锁。要避免死锁，应该将B挂起，直到A请求并释放绘图仪。"},{"title":"用户空间线程与内核线程","date":"2022-08-21T08:25:38.000Z","url":"/2022/08/21/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B/","tags":["操作系统","进程","线程","内核进程","用户空间进程"],"content":"有两种主要实现线程的方法：在用户空间中和在内核中。这两种方法互有利弊，同时也有混合的实现方式。 用户空间中实现线程把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。 优点 可以在仅支持进程的操作系统上使用线程。 线程切换代价小。当某个线程阻塞时，堆栈指针和程序计数器仅在用户空间中进行切换，不必陷入内核，对于内核来讲仍旧是当作一个进程来处理，故切换的时间比陷入内核要快一个数量级（甚至更多）。 允许每个进程定制调度算法。例如，在某些应用程序中，那些有垃圾收集线程的应用程序就不用担心线程会在不合适的时刻停止。 扩展性好。当各个进程的线程数量较多时，如果均为内核线程，那么内核需要管理的线程数量会过大。 缺点 如何实现阻塞系统调用。如果直接让线程阻塞系统调用，实际上也会阻塞该线程所属进程的其他线程，因为对于内核来讲实际上是该线程的进程进行系统调用，该进程整体被阻塞挂起，进程里的其他线程也不能运行。有些解决方案是，如果某些调用会阻塞，会提前通知。在某些UNIX版本中，有一个系统调用select可以允许调用者通知预期的read是否会阻塞。若有这个调用，那么库过程read就可以被新的操作替代，首先进行select调用，然后只有在安全的情形下（即不会阻塞）才进行read调用。如果read调用会被阻塞，有关的调用就不进行，代之以运行另一个线程。到了下次有关的运行系统取得控制权之后，就可以再次检查看看现在进行read调用是否安全。这个处理方法需要重写部分系统调用库，所以效率不高也不优雅，不过没有其他的可选方案了。 缺页中断时会将整个进程挂起。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘I&#x2F;O完成为止，尽管其他的线程是可以运行的。 由于进程内没有时钟中断，无法对线程进行超时调度处理。如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度（轮流）的方式调度进程。除非某个线程能够按照自己的意志进入运行时系统，否则调度程序就没有任何机会。 内核中实现线程内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。所有能够阻塞线程的调用都以系统调用的形式实现。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU（或者没有可运行的线程存在了）为止。由于在内核中创建或撤销线程的代价比较大，某些系统也会利用“线程池”的处理方式，当某个进程被撤销时，只是标记一下但不回收，以备下次当作新的线程使用。 优点 线程间的切换比较方便，每个线程可以像进程一样切换。比如某个进程中的线程引起了缺页中断，内核可以很方便地检查该进程是否有任何其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。 缺点 线程切换代价大，每一个阻塞调用都以系统调用的方式实现，会陷入内核进行切换，线程的操作（创建、终止等）比较多，就会带来很大的开销。 混合实现一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来，如图所示。如果采用这种方法，编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。这一模型带来最大的灵活度。 采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。（即将内核实现还是用户空间实现的程度交由程序员决定）"},{"title":"js彻搞懂原型","date":"2022-07-30T09:15:15.000Z","url":"/2022/07/30/js%E5%BD%BB%E6%90%9E%E6%87%82%E5%8E%9F%E5%9E%8B/","tags":["js","JavaScript","原型","对象"],"content":"js原型及对象根对象所有对象的根原型: Object.prototype new构造函数构建的对象，其原型为构造函数的prototype Function与ObjectFunction和Object本质上都是一个Function，其原型为Function的prototype 有意思的是，Function本身是一个函数，所以其原型为Function.prototype Function.prototype本身是一个对象，父原型是根对象 声明定义函数声明定义一个函数，实际上创建了两个对象，一个是函数对象Person，一个是Person的prototype constructorPerson是一个函数，由函数构造出来的对象，其construtor属性指向其构造函数，是原型链向上的__proto__的constructor。 值得注意的是，Function本身也是函数，其构造函数是Function 根节点对象的构造函数是Object 原型继承原型继承最简单的方式就是修改两个构造函数的prototype的继承关系 或 或者下面这种实现，但是不太好，因为会丢弃原先的Dog.prototype对象 参考链接"},{"title":"yay换源后更新包仍使用旧源: Could not resolve host: aur.tuna.tsinghua.edu.cn","date":"2022-05-12T06:45:10.000Z","url":"/2022/05/12/yay%E6%8D%A2%E6%BA%90%E5%90%8E%E6%9B%B4%E6%96%B0%E5%8C%85%E4%BB%8D%E4%BD%BF%E7%94%A8%E6%97%A7%E6%BA%90-Could-not-resolve-host-aur-tuna-tsinghua-edu-cn/","tags":["manjaro","yay","aur","清华源"],"content":"Could not resolve host: aur.tuna.tsinghua.edu.cn问题由于aur上游的一些问题，清华镜像于2022年3月1日移除aur镜像服务。所以自从3月份以后，本人使用manjaro系统的yay更新软件包，总是会报找不到aur.tuna.tsinghua.edu.cn的错误如下： 因为其实该网址已经不存在,之前在yay上设置的清华源还指向了这个地址所以报错。 于是想到将yay的源换回为默认的源: 但是依旧报错找不到aur.tuna.tsinghua.edu.cn,查看yay的配置文件也显示修改成功： 网上搜集了很久也没找到原因和解决办法，拖了2个多月无法更新系统的软件，试过用各种方法重新安装yay也没有用。 解决终于在今天无法忍受而把它解决掉了，其实很简单，清空yay的.cache即可。使用grep命令从系统根目录下查找aur.tuna.tinghua.edu.cn关键字： 发现在.cache&#x2F;yay文件中有许多相关内容： 于是想到原因可能是由于yay之前缓存了旧的不可用的地址，导致后面更新依旧重定向到了旧地址，所以尝试把yay所有的缓存文件删除： 再次执行更新…成功！！ 总结其实原因很简单，就是yay的包缓存文件缓存了旧的不可用地址，只要删除相关的缓存即可。而这种情况只会出现在更新之前旧的使用国内源下载的软件，使用yay下载没下过的包都不会有问题。于是我就卡了好久没更新，网上搜索也都是如何更换yay源的教程，这种小问题几乎找不到解决方案。希望可以帮助到有相同问题的小伙伴！"},{"title":"JavaScript js 正则表达式","date":"2022-02-25T03:35:01.000Z","url":"/2022/02/25/JavaScript-js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":["正则","js","javascript"],"content":"javascript常用正则表达式集 匹配大写和小写字母javascript的正则匹配表达式以/开头，以/结尾，[]中括号内表示任意一个其中的元素，+表示前面的元素有一个或多个。^表示开头需要为，$表示结尾需要为，同时有^和$表示开头结尾均匹配。 验证数字字符的正则表达式集"},{"title":"Hexo模板","date":"2022-02-24T16:00:00.000Z","url":"/2022/02/25/%E6%A8%A1%E6%9D%BF/","content":"一级标题二级标题三级标题四级标题五级标题六级标题这是一段普通文字： 予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？若夫霪雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。 这是加粗，斜体，删除线，链接。 这是块引用与嵌套块引用： 安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。 呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！ 这是行内代码：int a=1;。这是代码块： 这是无序列表： 苹果 红将军 元帅 香蕉 梨 这是有序列表： 打开冰箱 右手放在冰箱门拉手上 左手扶住冰箱主体 右手向后用力 把大象放进冰箱 关上冰箱 这是行内公式：$m\\times n$，这是块级公式： $C_{m\\times k}&#x3D;A_{m\\times n}\\cdot B_{n\\times k}$ 这是一张图片： 这是表格： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 水平分割线[^这是脚注]： "},{"title":"Hello World","date":"2022-02-24T07:24:36.910Z","url":"/2022/02/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment 清除缓存 生成并上传 等价于 "}]